package 시험0820;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class 시험02 {
	// DB CONN DATA
	private static String id = "root";
	private static String pw = "1234";
	private static String url = "jdbc:mysql://localhost:3306/opendatadb";

	// JDBC참조변수
	private static Connection conn = null; // DBMS 의 특정 DB와 연결되는 객체
	private static PreparedStatement pstmt = null; // SQL Query 전송용 객체
	private static ResultSet rs = null; // Select 결과물 담을 객체

	public static void conn() throws Exception {
		Class.forName("com.mysql.cj.jdbc.Driver");
		System.out.println("Driver Loading Success...");
		conn = DriverManager.getConnection(url,id,pw); //연결 객체 생성
		System.out.println("DB CONNECTED...");
		
	}

	public static List<BookDto> selectAll() throws SQLException {
		pstmt = conn.prepareStatement("SELECT * FROM tbl_book"); // prepareStatement를 사용해 걍 tbl_book에 있는 select의 값들을 SQL Query 전송용 객체에 저장
		//DB에서 조회한 결과를 rs에 담음
		rs = pstmt.executeQuery();
		
		List<BookDto> list = new ArrayList(); //새로운 배열을 list의 bookDto타입으로 변환
		BookDto dto = null; //참조변수 생성(일단 이렇게 말씀하시긴 했는데요... 이대로 될런지 고민이 됩니다.)
		if(rs!=null) {
			while(rs.next()) { //걍 입력받은 값이 있는 동안 ==> (rs.next == ture)
				dto = new BookDto(); //BookDto의 디폴트 생성자를 dto에 저장
				dto.setBookCode(rs.getLong("bookCode"));
				//getter 메서드를 이용해 rs 값을 가져옴 -> setBookCode를 이용해 dto == 디폴트 생성자에 저장(초기화도 아슬하지만 가능할 듟)
				dto.setBookname(rs.getString("bookname"));
				dto.setPublisher(rs.getString("publisher"));
				dto.setIsbn(rs.getString("isbn"));
				list.add(dto); //dto들을 list에 추가 == 저장

			}
		}
		
		return list;
	}

	public static BookDto select(Long bookCode) throws SQLException { //오류 발생하면 catch의 SQLException 예외 처리문으로 이동
		pstmt = conn.prepareStatement("SELECT * FROM tbl_book where bookCode =?");//?해당하는 값을 찍어줌 //단건조회
		pstmt.setLong(1, bookCode); // 파라미터 값(1L)을 전송객체에 세팅(수정)
		rs = pstmt.executeQuery(); //세팅(수정)한 것을 DB에서 조회, 그 조회한 결과를 rs에 담음 -> 이때 조회결과값이 없으면 null 아니면 ^^
		
		List<BookDto> list = new ArrayList(); //새로운 배열을 list의 bookDto타입으로 변환 이거 필요 x
		BookDto dto = null; 
		if(rs!=null) { //DB에서 조회한 값이 있으면
			rs.next(); 
			dto = new BookDto(); //BookDto의 디폴트 생성자를 dto에 저장
			dto.setBookCode(rs.getLong("bookCode"));
			//getter 메서드를 이용해 rs 값을 가져옴 -> setBookCode를 이용해 dto == ###디폴트 생성자에 저장###(초기화도 아슬하지만 가능할 듟) 
			dto.setBookname(rs.getString("bookname"));
			dto.setPublisher(rs.getString("publisher"));
			dto.setIsbn(rs.getString("isbn"));
			//=>걍 dto 세팅 -> 여기선 저장이겠다.
		}
		return dto; 
	}
	//executeQuery()
	//executeUpdate()
	//
			

	public static int insertBook(BookDto bookDto) throws SQLException { //bookDto전달
		pstmt = conn.prepareStatement("insert into tbl_book values(?,?,?,?)");		 
		//prepareStatement를 사용해 SQL 쿼리를 생성할 때 물음표(?)를 사용하여 나중에 값을 전달할 수 있도록 함
		pstmt.setLong(1, bookDto.getBookCode()); 
		//getter 메서드를 이용해 bookDto 객체의 bookCode 필드 값을 가져옴 -> setString이용해 첫번째 물읆표에 BookDto객체의 bookcode의 필드값 저장
		pstmt.setString(2, bookDto.getPublisher());
		pstmt.setString(2, bookDto.getBookname());  
		pstmt.setString(3,  bookDto.getPublisher());
		pstmt.setString(4, bookDto.getIsbn());
		
		//executeUpdate를 이욯해sql를 DB 로 전달
		int result = pstmt.executeUpdate();
		
		return result; //아무런 효과 x -> void 가능(return 사용 -> delete)
	}

	public static int updateBook(BookDto bookDto) throws SQLException {
	pstmt = conn.prepareStatement("insert tbl_book set bookName=?,publisher=?,isbn=? where bookCode=?");		
	pstmt.setString(1, bookDto.getBookname());
	//getter 메서드를 이용해 bookDto 객체의 bookCode 필드 값을 가져옴 -> setString이용해 첫번째 물읆표에 BookDto객체의 bookcode의 필드값 저장
	pstmt.setString(2, bookDto.getPublisher());
	pstmt.setString(3,  bookDto.getIsbn());
	pstmt.setLong(4, bookDto.getBookCode());
	
	//executeUpdate를 이용해  sql를 dbms 로 전달
	int result = pstmt.executeUpdate();
	
	return result;
	
	}

	public static int deleteBook(BookDto bookDto) throws SQLException { //select의 dto=디폴트 생성자를 파라미터 적용
		
		pstmt = conn.prepareStatement("delete form tbl_book where bookCode=?");
		pstmt.setLong(1, bookDto.getBookCode());

		//sql를 db 로 전달
		int result = pstmt.executeUpdate();
		
		return result;  //-> Update 안되면 0 되면 1
	}

	public static void main(String[] args) {
		try {
			// DBCONN
			conn();
			
			//TX START
			conn.setAutoCommit(false);
			// INSERT
			insertBook(new BookDto(1L, "도서명1", "출판사명1", "isbn-1")); //BookDto를 insertBook의 위치값으로 전달  
			insertBook(new BookDto(2L, "도서명1", "출판사명1", "isbn-1"));
			insertBook(new BookDto(3L, "도서명1", "출판사명1", "isbn-1"));
			insertBook(new BookDto(4L, "도서명1", "출판사명1", "isbn-1"));
			
			// SELECTALL //저장조회
			List<BookDto> allBook = selectAll(); //selectAll()의 값들을 BookDto형으로 all book이란 리스트 형태 저장
			System.out.println("SelectAll : ");
			allBook.forEach(System.out::println); //allBook를 반복해서 한번 씩 출력
	
			// SELECT
			BookDto dto = select(1L); //dto -> 디폴트 생성자에서 setting수정한 결과를 담고
			System.out.println("select : " + dto); 
			
			// UPDATE
			dto.setBookname("수정도서명-2"); 
			// select에서 1L으로 수정한 디폿트 생성재에서 (==dto에서) setting 메서들를 이용해 수정
			dto.setPublisher("수정출판사명-2"); //이하 동문
			int r1 = updateBook(dto); //dto(디폴트 생성자 값을 )
			if (r1 > 0)
				System.out.println("수정완료 : " + r1);

			// DELETE
			int r2 = deleteBook(dto); //select의 dto=디폴트 생성자를 파라미터 적용, result 반환한 결과 
			if (r2 > 0)
				System.out.println("삭제완료 : " + r2);

			//TX END
			conn.commit();
			
		} catch (Exception e) {
			//TX ROLLBACKALL
			try {conn.rollback();}catch(Exception e2) {} //문제 생기면 다시 전부 취소
		}finally {
			//자원제거 위의 객체들을 제거시켜 주는 역할
			try {rs.close();}catch(Exception e3) {}
			try {pstmt.close();}catch(Exception e3) {}
			try {conn.close();}catch(Exception e3) {}
			
		}

	}

}