package Ch06;

class Parent{
	void func1() {System.out.println("Parent's func1() call!");}
	void func2() {System.out.println("Parent's func2() call!");}
}

class Son extends Parent{
	//확장(추가된 함수), // 재정의
	void func2() {System.out.println("Son's func2() call!");}
}

public class C08UpDownCastingMain {

	public static void main(String[] args) {
		// NoCasting : 타입과 객체가 일치(Parent <- new Parent)
		Parent ob1 = new Parent();
		ob1.func1(); // Parent.func1
		ob1.func2(); // Parent.func2
		System.out.println("========");
		
		// NoCasting : 타입과 객체가 일치(Son <- new Son)
		Son ob2 = new Son();
		ob2.func1(); // 부모에게서 물려받은 func1 (Parent 버전 호출)
		ob2.func2(); // '재정의된' Son.func2 호출
		System.out.println("========");
		
		//UpCasting : 부모 타입 변수로 자식 객체를 참조 (자동 형변환)
		Parent ob3 = new Son();
		ob3.func1(); //컴파일타임 기준 Parent 타입 -> Parent.func1 호출
		ob3.func2(); // **중요** 오버라이딩된 Son.func2가 '동적 바인딩'으로 호출됨
					 // (참조 타입은 Parent지만, 실제 객체가 Son이므로 Son버전 실행)
		
		//Upcasting 된 상태에서
		//확장된(멤버추가) 멤버변수 접근 가능한가? X - > DownCasting 해야 가능
		//확장된(멤버추가) 멤버함수 접근 가능한가? X - > DownCasting 해야 가능
		//재정의된 멤버함수 접근 가능한가? O !!!!
		
		// 요약:
        // - UpCasting 상태(Parent 변수로 Son 객체를 가리킴)에서도
        //   '오버라이딩된 메서드'는 실제 객체 타입(Son) 기준으로 호출된다(다형성).
        // - 단, '자식에만 있는 새 멤버(함수/변수)'에는 Parent 타입으로는 접근 불가.
        //   → 필요하면 DownCasting으로 자식 타입으로 되돌려야 함.
		
	}

}
