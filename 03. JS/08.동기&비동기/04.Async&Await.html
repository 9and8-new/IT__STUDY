<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .box {
            width: 1280px;
            height: 800px;
            border: 1px solid;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
        }

        .box>.main-thread {
            width: 300px;
            border: 1px solid;
            height: 100%;
        }

        .box>.sub1-thread {
            width: 300px;
            border: 1px solid;
            height: 100%;
        }

        .box>.sub2-thread {
            width: 300px;
            border: 1px solid;
            height: 100%;
        }
    </style>
</head>

<body>
    <div class="box">
        <div class="main-thread"></div>
        <div class="sub1-thread"></div>
        <div class="sub2-thread"></div>
    </div>

    <script>
        const mainThreadEl = document.querySelector('.main-thread');
        const sub1ThreadEl = document.querySelector('.sub1-thread');
        const sub2ThreadEl = document.querySelector('.sub2-thread');

        // Probise 비동기 처리 객체 확인해보기
        // new Promise((resolve,reject)=>{ // 성공시 전달값 resolve, 실패시 reject
            
        //     setTimeout(()=>{
        //         const success =true; // false로 바꾸면 reject로 발동
        //         if(success){
        //             resolve("요청성공 : 서버로부터 데이터 수신완료!") // 성공했을시 resolve에 뜻넣기
        //         }else{
        //             reject("요청실패 : 서버오류(500)")
        //         }
        //     },3000);
        // }) 
        
        // .then((response)=>{console.log(response);}) // 정상응답시 후속 처리
        // .catch((error)=>{console.log(error)}) // 오류발생시 후속 처리

        // 메인스레드 생성(왼쪽 블럭 반복처리)
        let cnt = 0;
        setInterval(()=>{
            mainThreadEl.innerHTML += `MAIN THREAD...${++cnt}<br/>`;
        },1000)
        
        
        // 비동기처리 예약할때 async/  await
        // 비동기 기본 함수
        function sub_process_executor(val){
            return new Promise((resolve,reject)=>{// 위와동일. 성공시 반환, 실패시 반환

                setTimeout(()=>{
                    resolve(val); // 성공시 밸류값 리턴
                },3000) //3초뒤 반복실행
            }); 
        }

        // Async / Await 사용없이 비동기 처리 진행 / 비동기 처리 순서가 없다는 뜻
        // sub_process_executor(11)
        // .then((response)=>{console.log('sub1..',response);sub1ThreadEl.innerHTML=`sub1...${response}`})
        // .catch((error)=>{})

        // sub_process_executor(22)
        // .then((response)=>{console.log('sub2..',response);sub2ThreadEl.innerHTML=`sub2...${response}`})
        // .catch((error)=>{})
        // ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ sub1, sub2가 동시에 3초뒤에 나타남



        // Async / Await 를 이용한 비동기 처리 순서배치 // 비동기 처리 순서를 제어. 

        async function sub_process_order(){

        //  await을 사용해서 얘들끼리의 순서를 정해버리기
        // await을 사용하면 async을 써야한다.
        await sub_process_executor(22)
        .then((response)=>{console.log('sub2..',response);sub2ThreadEl.innerHTML=`sub2...${response}`})
        .catch((error)=>{})

        await sub_process_executor(11)
        .then((response)=>{console.log('sub1..',response);sub1ThreadEl.innerHTML=`sub1...${response}`})
        .catch((error)=>{})
        }
        sub_process_order(); 
        // 위쪽순서부터 실행.위쪽에서 setTimeout을 3초로 잡았으니 3초뒤 sub2, 그다음 3초뒤에 sub1이 나옴
    </script>
</body>

</html>