<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <script>
        // 배열 : 여러 자료Type을 저장하기 위한 자료구조
        // 배열은 순서번호(Index)를 가지고 있고 번호를 통해서 요소값에 접근가능
        // --------------------------------------------
        //let arr = ['str1', "str2", 'str3',null,true,false,undefined,{name:"홍길동",age:15}];
        //console.log(arr);
        //console.log(typeof arr[0]);
        //console.log(typeof arr[1]);
        //console.log(typeof arr[2]);
        //console.log(typeof arr[3]);
        //console.log(typeof arr[4]);
        //console.log(typeof arr[5]);
        //console.log(typeof arr[6]);
       //console.log(typeof arr[7]);
        // 데이터를 넣어서 계속 추가 가능함. 유연하게 사용가능
        // 자바스크립트의 배열은 동적확장이 가능하다
        //arr[8] = 100; 
        //console.log(arr);
        //arr[10] = "HELLOWORLD";
        //console.log(arr);
        //console.log(typeof arr[9], typeof arr[10]);

        //---------------------------------
        // 배열함수 : push(마지막 index + 1에 값추가), pop(마지막 index 값 제거)
        // push는 제일 마지막 위치에 정보를 넣는작업
        // pop은 제일 마지막 위치 정보를 꺼내는 작업
        //---------------------------------
        //arr.push('aaa');
        //arr.push('bbb');
        //arr.push('ccc'); // 변수명.push(추가할 데이터) => 데이터를 제일 뒤에 추가
        //console.log(arr); // 제일 마지막에 넣은 ccc가 제일 뒤에 뜬다.
        //arr.pop(); // 변수명.pop() => 제일 마지막 데이터를 삭제
        //console.log(arr);
        //arr.pop();
        //console.log(arr); // pop을 써서 제일 마지막에 추가된 c랑 b를 날린다.
        // ['str1', 'str2', 'str3', null, true, false, undefined, {…}, 100, empty, 'HELLOWORLD', 'aaa']

        //==================---------------------------
        //배열 함수 : forEach / 콜백함수임 => 로직을 받음
        // 배열 내의 모든 요소를 순차적으로 접근하는 반복구문
        // callback함수(로직을 전달, ()=>{})
        // arr.forEach((요소명)=>{처리할 코드})
        // --------------------------------------------
        //console.log("------------------");
        //arr.forEach((item)=>{console.log('item',item); }); // 각각의 요소는 item이라고 함 / 반복문

        // --------------------------------------------
        // 정렬 : .sort((비교인자1,비교인자2)=>{retrn 비교인자1 - 비교인자2})
        // callback함수.
        // 오름차순 : arr.sort((a,b)=>{return a-b})
        // 내림차순 : arr.sort((a,b)=>{return b-a})
        // --------------------------------------------
        // let arr2=[10,55,11,24,5,44,1,22]
        // console.log(arr2);
        // 오름차순 정렬 : .sort()
        // arr2.sort((a,b)=>{return a-b;}); // 콜백함수도 가능
        // 내림차순 정렬 :
        // arr2.sort((a,b)=>{return b-a;}); // 콜백함수는 계속 만들어봐야 작동원리를 알게됨
        // 약식
        // arr2.sort((a,b)=> b-a); // 코드라인이 한줄인 단순한 오름 내림차순이면 retrun빼고 약식으로 가능함 
        // console.log(arr2);
        // --------------------------------------------
        // 필터 : filter : 배열내에서 특정 요소만 필터링
        // arr.filter((요소명)=>{return 조건식})
        // 필터링된 요소만 묶은 배열이 따로 생성
        // --------------------------------------------
        // let arr3 = [11,'str1',22, "str2",33, 'str3',10.5,null,true,false,undefined,101,{name:"홍길동",age:15}];

        // let result = arr3.filter((item)=>{return typeof item=="number"}); // arr3에서 item에서 number만 뽑아옴
        // console.log(result); // 문자열만 확인됨

        // let result2 = arr3.filter((item)=>{return typeof item=="string"}); // 한줄이라서 약식으로 return빼고 가능
        // console.log(result2);
        // --------------------------------------------
        // 누산 : 누적합, 누적곱... 누적작업
        // arr.reduce((누적변수,요소명)=>{처리로직},누산변수 초기값)
        // 합을 구하는 누산작업 : .reduce(()=>{},누산변수 초기값) 메서드는 배열의 각 요소에 대해 주어진 리듀서 (reducer) 함수를 실행하고, 하나의 결과값을 반환
        // --------------------------------------------
        // const sum = arr3.filter((item)=>{return typeof item=="number"})     // 숫자값만 필터
        //                 .reduce((sum,item)=>{return sum+item;},0)                                   //누적합 구하기
        //                  체인형태로 .으로 붙여서 바로 작업이 가능함.

        // console.log(sum);

        // ----------------------------------
        // 배열object 처리 [{},{},{},{}...]
        // ----------------------------------
        let arr_5 = [
            {pid:"1",pname:"모니터",price:100,amount:50},
            {pid:"2",pname:"노트북",price:200,amount:15},
            {pid:"3",pname:"냉장고",price:250,amount:30},
            {pid:"4",pname:"데스크탑",price:70,amount:19},
            {pid:"5",pname:"가습기",price:10,amount:200},
        ];
        // console.log(arr_5);
        // arr_5.forEach((item)=>{console.log(item);})
        // arr_5.forEach(item=>{console.log(item);}) // 약식으로 item에 ()도 생략가능
        // arr_5.forEach((item,index)=>{console.log(index,item);}) // index도 넣으면 배열의 순서번호도 알 수 있음.
        // arr_5.forEach((item,index)=>{console.log(item["price"]);}) // 첨자연산자[]추가 []안에 key값을 넣어 아이템의 value값들을 확인가능.

        // 각 item의 가격이 100이상인 object만 필터링
        // const filter_01= arr_5.filter(item=>{item["price"]>=100;}) // item의 price가 100이상
        // const filter_01= arr_5.filter(item=>item.price>=100) // 이런식으로도 약식 가능함
        // console.log(filter_01);

        // // 각 아이템 수량이 30개 이하인 object만 필터링(>=,<=)
        // const filter_02= arr_5.filter(item=>item.amount<=30)
        // console.log(filter_02);
        // // 각 아이템 가격이 100만원 이상인 item의 가격 총합(누적)을 구하세요.
        // const sum = arr_5.filter(item=>item.price>=100) // or arr_5.filter((item)=>{return item.price>=100;})
        //                  .reduce((sum,item)=>{return sum+ (item.price * item.amount)},0);
        // console.log('100만원 이상인 item의 price 누적합',sum)
        // ----------------------------------
        // 재구성 배열.map(()=>{})
        // mpp : 기존 배열의 새로운 형태의 배열로 재구성(**중요함**)
        // arr.map((요소명)=>{return 재구성할 요소의 형태})
        // 새로운 배열이 만들어짐
        //  Array 인스턴스의 map() 메서드는 호출한 배열의 모든 요소에 주어진 함수를 호출한 결과로 채운 새로운 배열을 생성
        // ----------------------------------
        // let arr_6 = [
        //     {pid:"1",pname:"모니터",price:100,amount:50},
        //     {pid:"2",pname:"노트북",price:200,amount:15},
        //     {pid:"3",pname:"냉장고",price:250,amount:30},
        //     {pid:"4",pname:"데스크탑",price:70,amount:19},
        //     {pid:"5",pname:"가습기",price:10,amount:200},
        // ];

        // let maped_01= arr_6.map((item)=>{
            
        //     item={...item,"total_price":item.price*item.amount}; // 대입연산자 사용후 ... = 아이템에있는 내용(속성)을 그대로 옮겨옴
        //     // ... = 전개 연산자 / 새로운 제목을 만들어냄 ex) ...item,"아몰랑":item.price*item.amount => 뒤에 계산한것을 아몰랑이라는 제목으로 생성
        //     console.log("!",item);    
        //     return item;
        // }) // 자주쓰임. 프론트에서React사용할때 밥먹듯이 사용함
        // console.log(maped_01);

        // 수량이 30이상인 요소만 필터링해서, price가 낮은값우선 오름차순 / price*amount 항목추가
        // const maped_02 = arr_6.filter((item)=>{return item.amount>=30})
        //                       .sort((a,b)=>{return a.price-b.price;})
        //                       .map((item)=>{
        //                         item={...item,"total_price":item.price*item.amount};
        //                         return item;
        //                     })

         let employees = [
            { id: 1, name: "김철수", age: 35, department: "개발", salary: 6000, years: 10 },
            { id: 2, name: "이영희", age: 28, department: "디자인", salary: 5000, years: 5 },
            { id: 3, name: "박지성", age: 40, department: "마케팅", salary: 7000, years: 15 },
            { id: 4, name: "손흥민", age: 30, department: "개발", salary: 6500, years: 7 },
            { id: 5, name: "정우성", age: 45, department: "경영", salary: 9000, years: 20 },
            { id: 6, name: "한지민", age: 29, department: "디자인", salary: 5200, years: 6 },
            { id: 7, name: "강호동", age: 50, department: "경영", salary: 8500, years: 25 },
            { id: 8, name: "유재석", age: 42, department: "마케팅", salary: 7500, years: 18 },
            { id: 9, name: "송중기", age: 32, department: "개발", salary: 6200, years: 8 },
            { id: 10, name: "수지", age: 26, department: "디자인", salary: 4800, years: 3 }
        ];
        //연봉이(salary) 6000이상이면서 근속연수(years)가 7년이상인(item.salary>=6000 && item.years>=7) 직원만 필터링해서 배열로 저장 확인
        const employees_01 = employees.filter((item)=>{return item.salary>=6000 && item.years>=7}) 
        console.log(employees_01);

        //모든 직원의 연봉(salary) 기준으로 내림차순 정렬한 배열 새로 만들기
        const employees_02 = employees.sort((a,b)=>{return b.salary - a.salary})
        console.log(employees_02);

        //모든 직원의 연봉(salary) 에 근속연수*100 만큼의 보너스를 추가하여 total_salary필드를 추가한 배열을 반환
        const employees_03 = employees.map((item)=>({...item,"total_salary":item.salary + item.years * 100})) 
        console.log(employees_03);
        // const employees_03 = employees.map((item)=>{
        //  item = {...item,"total_salary": item.salary+(item.years*100)}
        // return item;
        //  })

        //department(부서) 별로 직원들의 연봉총합을 구하세요
        // const employees_04 = employees.filter((item)=>{item.department=="개발"})
        //                               .reduce((sum,item)=>{})
        
        // sum = {"개발": "", "마케팅":""}
        const employees_04 = employees.reduce((sum,item)=>{
            // console.log(item);
            sum[item.department]=sum[item.department]==undefined?item.salary:sum[item.department]+item.salary; // 대입연산자기준 오른쪽은 값으로처리됨
            // department가 없으면 새로운salary입력, 있으면 salary가 추가됨
            console.log(sum);
            return sum;
        },{});
        console.log(employees_04);

        // 연봉(salary)가 가장높은 직원을 찾아 객체하나만 반환(문서에서 find를 찾아보세요 - !)
        const employees_05 = employees.sort((a,b)=>{return b.salary - a.salary})[0];
        console.log(employees_05)

        // 최대값 구하기
        const max_item2 = employees.find((item)=>{return item.salary==employees_05.salary;})
        console.log(max_item2);



    </script>

</body>
</html>